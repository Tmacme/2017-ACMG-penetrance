---
title: "ACMG-ClinVar Markdown File"
author: "James Diao"
date: "October 15, 2016"
output: html_document
---

> Working Directory: `r getwd()`

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, eval = T, cache = T, warning = F, message = F)
```

```{r packages, include = F}
#save.image("/Users/jamesdiao/Documents/Kohane_Lab/test_10_14_2016")
#load("/Users/jamesdiao/Documents/Kohane_Lab/test_10_14_2016")
suppressMessages(library(dplyr))
suppressMessages(library(tidyr))
suppressMessages(library(ggplot2))
suppressMessages(library(scrapeR))
suppressMessages(library(RMySQL))
unzip("ExAC.zip")
unzip("Temp_Files.zip")
use_clinvar <- NULL
#use_clinvar <- "Temp_Files/clinvar_2016-08-31.vcf"
skip_download <- "1000G" %in% system("ls",intern = T)
skip_processing <- "ACMG_1000G" %in% system("ls",intern = T)
```

## Download, Transform, and Load Data

> 1. Access 1000 Genomes Phase 3 Populations Map: ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/integrated_call_samples_v3.20130502.ALL.panel

```{r population_map}
#download phase 3 populations map
download.file(url = "ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/integrated_call_samples_v3.20130502.ALL.panel", destfile = "Temp_Files/phase3map.txt", method = "internal")
#read the map and delete the file
map <- read.table(file = "Temp_Files/phase3map.txt", stringsAsFactors = F, header = T) %>% as.data.frame
#display
map[1:3,]
#Make list of populations and superpopulations for later plotting
pop.table <- map[!duplicated(map$pop),] %>% 
  select(contains("pop")) %>% arrange(super_pop, pop)
super <- pop.table$super_pop %>% setNames(pop.table$pop)
super.levels <- unique(pop.table$super_pop)
pop.levels <- unique(pop.table$pop)
print(super, quote = F) 
#Plot distribution of ancestral backgrounds
Population = factor(as.character(map$pop), levels = pop.levels)
ggplot(map, aes(map$super_pop, fill = Population)) + 
  geom_bar(color = 'black', width = 0.5) + 
  ylab ("No. of Individuals") + xlab ("Superpopulation") + 
  ggtitle("1000 Genomes - Samples by Population")
rm(Population)
```

> 2. Scrape ACMG gene panel from ClinVar: 
http://www.ncbi.nlm.nih.gov/clinvar/docs/acmg/

```{r scrape_acmg}
### Scraped Clinvar website for ACMG-relevant genes
scrape_ACMG <- function() {
  ACMG.page <- scrape(url ="http://www.ncbi.nlm.nih.gov/clinvar/docs/acmg/")[[1]]
  ACMG.table <- readHTMLTable(ACMG.page, stringsAsFactors = F, header = T)[[1]]
  colnames(ACMG.table) <- c("Disease", "MedGen","Gene","Variations_Link")
  ### Formatting correction: separating merged gene blocks
  badrow <- which(apply(ACMG.table, 1, function(row) !any(grepl("ClinVar", row))))
  ACMG.table[badrow,"Gene"] <- ACMG.table[badrow-1,"Gene"]
  ### Formatting corrections: sliding
  mismatch <- 0
  while(any(ACMG.table[,"Gene"] == "ClinVar")) {
    mismatch <- which(ACMG.table[,"MedGen"]!="MedGen")
    ACMG.table[mismatch,2:3] <- ACMG.table[mismatch,1:2]
    for (row in mismatch) { ACMG.table[row,"Disease"] <- ACMG.table[row-1, "Disease"] }
  }
  ACMG.panel <- ACMG.table[,"Gene"] %>% strsplit(" \\(") %>% 
    sapply(function(x) x[1]) %>% unique
}
ACMG.panel <- scrape_ACMG()
```

> 3. Download ClinVar VCF from: 
ftp://ftp.ncbi.nlm.nih.gov/pub/clinvar/vcf_GRCh37/clinvar.vcf.gz

```{r clinvar}
#Number to interpretation
clnsig_map <- c(0:7,255,-1) %>% setNames(c("Uncertain",
  "Not_Provided","Benign","Likely_Benign","Likely_Pathogenic",
  "Pathogenic","Drug_Response","Histocompatibility","Other","NA")) 

if (is.null(use_clinvar)) {
  clinvar_file <- sprintf("Temp_Files/clinvar_%s.vcf.gz", Sys.Date())
  download.file(url = "ftp://ftp.ncbi.nlm.nih.gov/pub/clinvar/vcf_GRCh37/clinvar.vcf.gz", 
                destfile = clinvar_file, method = "internal")
  system(sprintf("gunzip %s", clinvar_file))
  clinvar_file <- sprintf("Temp_Files/clinvar_%s.vcf", Sys.Date())
} else {
  clinvar_file <- use_clinvar
}

get_clinvar <- function(clinvar_file) {
  file.by.line <- readLines(clinvar_file)
  file_date <- as.Date(strsplit(file.by.line[2],"=")[[1]][2], "%Y%m%d")
  system(sprintf("mv %s Temp_Files/clinvar_%s.vcf", clinvar_file, file_date))
  clean.lines <- sub(paste0("##", ".*"), "", file.by.line)
  input <- read.table(text = paste(clean.lines, collapse = "\n"), header = F, stringsAsFactors = F, 
                      comment.char = "", quote = "", sep = "\t")
  colnames(input) <- c("CHROM","POS","ID","REF","ALT","QUAL","FILTER","INFO")
  input <- input[nchar(input$REF)==1,] #deletions
  alt_num <- sapply(strsplit(input$ALT,","),length) #number of alts
  acceptable_nchar <- 2*alt_num-1 #adds in the length from commas, if each alt is 1 nt.
  input <- input[nchar(input$ALT)==acceptable_nchar,] #insertions
  input$ALT <- strsplit(input$ALT,",")
  split_all <- strsplit(input$INFO,";")
  
  split_info <- function(name) {
    sapply(split_all, function(entry) {
      entry[grep(name,entry)]
    }) %>% strsplit("=") %>% sapply(function(x) x[2]) %>% strsplit(",")
  }
  input$CLNALLE <- split_info("CLNALLE=") %>% sapply(as.integer)
  input$CLNSIG <- split_info("CLNSIG=")
  input$CLNDBN <- split_info("CLNDBN=")
  input$CLNDSDBID <- split_info("CLNDSDBID=")
  
  #CLNALLE has 0,-1,3,4 --> CLNSIG has 1,2,3,4 --> ALT has 1. 
  taking <- sapply(input$CLNALLE, function(x) x[x>0] ) #Actual elements > 0. Keep these in CLNSIG and ALT 
  taking_loc <- sapply(input$CLNALLE, function(x) which(x>0) )#Tracks locations for keeping in CLNALLE
  keep <- sapply(taking, length)>0 #reduce everything to get rid of 0 and -1
  # Reduce, reduce, reduce. 
  taking <- taking[keep]
  taking_loc <- taking_loc[keep]
  input <- input[keep,]
  
  #Make this more readable
  input$ALT <- sapply(1:nrow(input), function(row) {
    input$ALT[[row]][taking[[row]]]
  })
  
  col_subset <- function(name) {
    sapply(1:nrow(input), function(row) {
      unlist(input[row,name])[taking_loc[[row]]]
    })
  }
  input$CLNSIG <- col_subset("CLNSIG")
  input$CLNALLE <- col_subset("CLNALLE")
  input$CLNDBN <- col_subset("CLNDBN")
  input$CLNDSDBID <- col_subset("CLNDSDBID")
  
  input <- unnest(input) %>% unite(VAR_ID, CHROM, POS, REF, ALT, sep = "_", remove = F) %>%
    select(VAR_ID, CHROM, POS, ID, REF, ALT, CLNALLE, CLNSIG, everything()) %>% 
    mutate(CLNSIG = strsplit(CLNSIG,"|",fixed = T)) %>% 
    mutate(CLNDBN = strsplit(CLNDBN,"|",fixed = T)) %>% 
    mutate(POS = as.integer(POS)) %>% 
    mutate(CLNDSDBID = strsplit(CLNDSDBID,"|",fixed = T)) 
  input$CLNSIG <- sapply(input$CLNSIG, function(x) as.integer(x))
  input$INTERP <- sapply(input$CLNSIG, function(x) any(x %in% c(4,5)) ) 
  input
}
clinvar <- get_clinvar(clinvar_file)
```

> 4. Download 1000 Genomes VCFs and collect ACMG-56 regions (via tabix): ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ALL.[chrom].phase3_[version].20130502.genotypes.vcf.gz

```{r download_all}
download_1000g <- function(gene, download) {
  #for tracking: #gene %>% paste(which(ACMG.panel==gene)) %>% paste(length(ACMG.panel), sep = "/") %>% print
  success <- FALSE
  refGene <- sprintf("select * from refGene where name2 = \"%s\" limit 20", gene) %>% query
  UCSC <- select(refGene, name, chrom, start = txStart, end = txEnd)
  if (nrow(UCSC) == 0) { #No hit on refGene
    return(rep("NOT_FOUND",5) %>% setNames(c("name","chrom","start","end","downloaded")))
  } else {
    if (nrow(UCSC) > 1) #Multiple hits: take the widest range
      UCSC <- UCSC[which.max(UCSC$end-UCSC$start),]
    if (download) {
    # gets [n] from chr[n]
    chrom.num <- strsplit(UCSC$chrom, split = "chr")[[1]][2]
    # different version for chromosomes X and Y
    version <- switch(chrom.num, "X" = "shapeit2_mvncall_integrated_v1b",
                      "Y" = "integrated_v2a", "shapeit2_mvncall_integrated_v5a")
    command <- paste("tabix -h ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ALL.%s.",
                     "phase3_%s.20130502.genotypes.vcf.gz %s:%s-%s > %s_genotypes.vcf", sep = "")
    sprintf(command, UCSC$chrom, version, chrom.num, UCSC$start, UCSC$end, gene) %>% system
    Sys.sleep(2)
    # Checks whether the file exists and has non-zero size
    exists <- grepl(paste(gene,"_genotypes.vcf",sep =""), system("ls", intern = T)) %>% sum > 0
    file.size <- strsplit(paste("stat ","_genotypes.vcf", sep = gene) %>% 
                            system(intern = T), " ")[[1]][8]
    success <- exists & file.size > 0
    }
  }
  return(c(UCSC,"downloaded" = success))
}

if (!skip_download & !skip_processing) {
  system("mkdir 1000G")
  setwd(paste(getwd(), "1000G", sep = "/"))
  for (con in dbListConnections(MySQL())) dbDisconnect(con)
  con <- dbConnect(MySQL(), user = 'genome',
                   dbname = 'hg19', host = 'genome-mysql.cse.ucsc.edu',
                   unix.sock = "/Applications/MAMP/tmp/mysql/mysql.sock")
  query <- function (input) { suppressWarnings(dbGetQuery(con, input)) }
  download_output <- sapply(ACMG.panel, function(gene) download_1000g(gene, download = T)) %>% t
  print(download_output, quote = F)
  download_output <- download_output %>% 
    apply(2, unlist) %>% 
    as.data.frame(stringsAsFactors = F) %>% 
    mutate("gene" = rownames(download_output)) %>% 
    select(gene, everything()) %>% 
    filter(downloaded != "NOT_FOUND")
  download_output <- download_output %>%
    mutate(chrom = sapply(strsplit(download_output$chrom,"chr"), function(x) x[2]), 
           start = as.integer(start), end = as.integer(end), 
           downloaded = as.logical(downloaded))
  write.table(download_output, file = "download_output.txt", 
              row.names = F, col.names = T, quote = F, sep = "\t")
  system("rm *.genotypes.vcf.gz.tbi")
}
```

> 5. Import and Process ExAC and 1000 Genomes

```{r import_exac}
import.file.exac <- function(gene) {
  file_name <- paste("ExAC",paste(gene,"exac.csv", sep = "_"), sep= "/")
  output <- read.csv(file_name, stringsAsFactors = FALSE)
  output$Number.of.Hemizygotes <- NULL #Inconsistently present column; removal allows row aggregation
  output <- cbind(GENE = gene, output[nchar(paste(output$Alternate,output$Reference))==3,]) %>% 
    select(GENE, AF_EXAC = Allele.Frequency, CHROM=Chrom, POS=Position, 
           ID=RSID, REF=Reference, ALT=Alternate, everything()) %>% 
    unite(VAR_ID, CHROM, POS, REF, ALT, sep = "_", remove = F) %>% arrange(VAR_ID)
  tags <- list("African","Latino","East.Asian","European","South.Asian")
  output$Allele.Count.European <- output$Allele.Count.European..Non.Finnish. + output$Allele.Count.Finnish
  output$Allele.Number.European <- output$Allele.Number.European..Non.Finnish. + output$Allele.Number.Finnish
  exac_af <- output[,sprintf("Allele.Count.%s", tags)] / output[,sprintf("Allele.Number.%s", tags)]
  colnames(exac_af) <- sprintf("AF_EXAC_%s", c("AFR","AMR","EAS","EUR","SAS"))
  output <- cbind(output, exac_af) %>% 
    select(GENE, AF_EXAC, AF_EXAC_AFR, AF_EXAC_AMR, AF_EXAC_EAS, AF_EXAC_EUR, AF_EXAC_SAS, everything())
}

# Import ExAC data for all ACMG
ACMG.exac <- NULL
for (gene in ACMG.panel) {
  #print(sprintf("[%d/%d] %s",which(gene==ACMG.panel),length(ACMG.panel),gene))
  ACMG.exac <- rbind(ACMG.exac,import.file.exac(gene))
}
#Display and remove duplicates
#ACMG.exac[duplicated(ACMG.exac$VAR_ID),1:8]
ACMG.exac <- ACMG.exac[!duplicated(ACMG.exac$VAR_ID),]
```

```{r import_1000g}
import.file.1000g <- function(gene) {
  sprintf("%s [%s/%s]", gene, grep(gene, ACMG.panel), length(ACMG.panel)) %>% cat
  name <- paste("1000G",paste(gene,"genotypes.vcf", sep = "_"), sep = "/")
  output <- read.table(paste(getwd(),name,sep="/"), stringsAsFactors = FALSE)
  #Add header
  names(output)[1:length(header)] <- header
  #Remove all single alt indels
  output <- output[nchar(output$REF)==1,] #deletions
  alt_num <- sapply(strsplit(output$ALT,","),length) #number of alts
  acceptable_nchar <- 2*alt_num-1 #adds in the length from commas, if each alt is 1 nt.
  output <- output[nchar(output$ALT)==acceptable_nchar,] #insertions
  alt_num <- sapply(strsplit(output$ALT,","),length) #recalculate
  paired = which(alt_num!=1) #all with ,
  #Add AF Column
  af <- strsplit(output$INFO,";") %>% sapply("[", 2) %>% 
    strsplit("AF=") %>% sapply("[", 2) %>% strsplit(",") %>% sapply(as.numeric)
  output <- cbind(GENE = gene, "AF_1000G"=I(af), output) #Places it at the front of output
  front_cols <- 1:(grep("HG00096",colnames(output))-1)
  if (length(paired)!=0) {
    #Limit max vector length by sapply(strsplit(output$ALT,","),length)
    sapply(paired, function(rownum) { #For every row
      sapply(as.character(1:alt_num[rownum]), function(num) {
        grepl(paste(num,"|",sep = ""), output[rownum,-front_cols], fixed=T) +
        grepl(paste("|",num,sep = ""), output[rownum,-front_cols], fixed=T)
      }) %>% t -> temp
      split(temp, rep(1:ncol(temp), each = nrow(temp))) %>% setNames(NULL) 
      #Separate into list of vectors (1 entry for counting each ALT)
    }) %>% t -> insert
    insert <- cbind(output[paired,front_cols],insert)
    colnames(insert) <- colnames(output)
    insert <- insert %>% #adds front_col info
      mutate(ALT = strsplit(ALT,",")) %>% #Splits ALTS
      unnest() %>% #Unnests everything
      select(GENE, AF_1000G, CHROM, POS, ID, REF, ALT, everything()) #Reorders everything
    output <- output[-paired,] #Removes paired
  }
  output <- cbind(output[,front_cols],
                  apply(output[,-front_cols], 2, function(y) {
                    grepl("1|", y, fixed=T) +
                    grepl("|1", y, fixed=T)
                  }) ) #convert to logical
  if (length(paired)!=0)
    output <- rbind(output, insert) #joins the two
  output$AF_1000G <- as.numeric(output$AF_1000G)
  unite(output, VAR_ID, CHROM, POS, REF, ALT, sep = "_", remove = F) %>% arrange(VAR_ID)
  #Make VAR_ID, arrange by VAR_ID
}

if (skip_processing) {
  load(file = "ACMG_1000G")
} else {
  # Import 1000G data for all ACMG
  ACMG.1000g <- NULL
  header <- c("CHROM", "POS", "ID", "REF", "ALT", "QUAL", "FILTER", "INFO", "FORMAT", as.character(map$sample))
  for (gene in ACMG.panel) {
    #print(sprintf("[%d/%d] %s",which(gene==ACMG.panel),length(ACMG.panel),gene))
    ACMG.1000g <- rbind(ACMG.1000g,import.file.1000g(gene))
  }
  #Display and remove duplicates
  ACMG.1000g <- ACMG.1000g[!duplicated(ACMG.1000g$VAR_ID),]
}
```

## Analysis of Data

```{r prettyprint} 
### For plotting population level data:
prettyprint <- function(values, sd, title, xlabel, ylabel, ylimit) {
  if (missing(sd)) sd <- TRUE
  if (missing(title)) title <- NULL
  if (missing(xlabel)) xlabel <- "Population"
  if (missing(ylabel)) ylabel <- NULL
  if (missing(ylimit)) ylimit <- NULL
  colnames(values) <- c("Mean","SD")
  values$Population <- factor(pop.levels, levels = pop.levels)
  values$Superpopulation <- factor(super[pop.levels], levels = super.levels)
  
  plot.pop <- ggplot(values, aes(x=Population, y=Mean, fill = Superpopulation)) +
    geom_bar(stat = "identity") + ggtitle(title) + xlab(xlabel) + ylab(ylabel) +
    theme_minimal() + theme(axis.text.x = element_text(angle = -45, hjust = 0.4))
  if (sd) {
    if (min(values$Mean - values$SD)<0)
      plot.pop <- plot.pop + geom_errorbar(aes(
        ymin = pmax(0,values$Mean - values$SD), 
        ymax = values$Mean + values$SD, width = 0.5))
    else 
      plot.pop <- plot.pop + geom_errorbar(aes(ymin = values$Mean - values$SD, 
                                               ymax = values$Mean + values$SD, width = 0.5))
  } else {values$SD = 0}
  if (length(ylimit)==2)
    plot.pop <- plot.pop + ylim(ylimit[1],ylimit[2])
  else
    plot.pop <- plot.pop + ylim(0, 1.1*max(values$Mean + values$SD))
  plot.pop
}
```

> 1. Merge ClinVar with 1000 Genomes and ExAC

```{r print_merge_details}
inter <- intersect(clinvar$VAR_ID[clinvar$INTERP], ACMG.1000g$VAR_ID)
clinvar_merged <- clinvar[(clinvar$VAR_ID %in% inter),] %>% arrange(VAR_ID)
ACMG_merged <- ACMG.1000g[ACMG.1000g$VAR_ID %in% inter,] %>% arrange(VAR_ID)
front_cols <- 1:(grep("HG00096",colnames(ACMG.1000g))-1)
merged_1000g <- cbind(ACMG_merged[,c("GENE","AF_1000G")], clinvar_merged,
                ACMG_merged[,-front_cols])

inter <- intersect(clinvar$VAR_ID[clinvar$INTERP], ACMG.exac$VAR_ID)
merged_exac <- cbind(clinvar[(clinvar$VAR_ID %in% inter),] %>% arrange(VAR_ID), 
  ACMG.exac %>% select(VAR_ID, contains("AF_"), GENE) %>% filter(VAR_ID %in% inter) %>% 
  arrange(VAR_ID) %>% select(-VAR_ID)) %>% select(VAR_ID, GENE, AF_EXAC, contains("AF_"), everything())

#count up all pathogenic ClinVar in ACMG regions
if(skip_download) 
  download_output <- read.table("1000G/download_output.txt", header = T, stringsAsFactors = F)
is.acmg <- function(row) {
  genes <- which(row$CHROM == download_output$chrom)
  sapply(genes, function(gene) {
    between(row$POS, download_output[gene,]$start, download_output[gene,]$end)
  }) %>% any
}
acmg_tx <- sum(apply(clinvar[clinvar$INTERP,], 1, is.acmg))
clinvar_bp <- data.frame(Number.of.Variants = 
  c(nrow(clinvar), sum(clinvar$INTERP), acmg_tx, 
  nrow(merged_exac), nrow(merged_1000g)) %>% 
  setNames(c("Total ClinVar","ClinVar and Pathogenic","Patho-ClinVar and in ACMG",
             "ACMG Patho-ClinVar and in ExAC","ACMG Patho-ClinVar and in 1000G")))
acmg_1000g_bp <- data.frame(Number.of.Variants = 
  c(nrow(ACMG.1000g),intersect(clinvar$VAR_ID, ACMG.1000g$VAR_ID) %>% 
  length, nrow(merged_1000g)) %>% setNames(c("Total ACMG-1000G",
  "ACMG-1000G in ClinVar","ACMG-1000G in ClinVar and Pathogenic")))
acmg_exac_bp <- data.frame(Number.of.Variants = 
  c(nrow(ACMG.exac),intersect(clinvar$VAR_ID, ACMG.exac$VAR_ID) %>% 
  length, nrow(merged_exac)) %>% setNames(c("Total ACMG-ExAC",
  "ACMG-ExAC in ClinVar","ACMG-ExAC in ClinVar and Pathogenic")))
clinvar_bp
acmg_1000g_bp
acmg_exac_bp
par(mfrow=c(1,1))
```

> 2. Gene distribution of ClinVar Pathogenic Variants

```{r gene_distribution}
rel_genes <- sort(table(merged_1000g$GENE), decreasing=T)
#print(rel_genes[rel_genes > 0])
barplot(rel_genes, las = 2, cex.names = 0.7, ylab = "No. of Pathogenic Variants", 
        main = "Gene distribution of ClinVar Pathogenic Variants in 1000 Genomes")
rel_genes <- sort(table(merged_exac$GENE), decreasing=T)
#print(rel_genes[rel_genes > 0])
barplot(rel_genes, las = 2, cex.names = 0.7, ylab = "No. of Pathogenic Variants", 
        main = "Gene distribution of ClinVar Pathogenic Variants in ExAC")
```

> 3. Overall Non-Reference Sites

```{r all_var_plot}
### 1000 Genomes
front_cols <- 1:(grep("HG00096",colnames(ACMG.1000g))-1)
sapply(pop.levels, function(pop) {
  #Counts the number of non-reference sites in a gene
  temp <- apply(ACMG.1000g[,length(front_cols)+which(map$pop == pop)], 
                2, function(col) col!=0) %>% colSums
  c(mean(temp), sd(temp))
}) %>% t %>% tbl_df -> values #Number of non-reference sites across the different populations
colnames(values) <- c("Mean","SD")
values$Population <- factor(pop.levels, levels = pop.levels)
values$Superpopulation <- factor(super[pop.levels], levels = super.levels)
prettyprint(values, title = "ACMG-56: Mean in 1000 Genomes", sd = T, ylimit = NULL, 
            xlabel = "Population", ylabel = "Mean No. of Non-Reference Sites")

### ExAC
#Each element is the probability that at least 1 of the 2 alleles are non-reference.
exac_prob <- (1-(1-ACMG.exac[,sprintf("AF_EXAC_%s",super.levels)])^2)
exac_values <- data.frame(exac_prob %>% colSums(na.rm = T), super.levels)
colnames(exac_values) = c("values","Superpopulation")
ggplot(exac_values, aes(x = Superpopulation, y=values, fill = Superpopulation)) + 
  geom_bar(stat = "identity") + theme_minimal() + ggtitle("ACMG-56: Mean in ExAC") + 
  xlab("Population") + ylab("Mean No. of Non-Reference Sites") + 
  ylim(0,1.1*max(exac_values$values))
```

> 4. Pathogenic Non-Reference Sites

```{r pathogenic_var_plot}
### 1000 Genomes
sapply(pop.levels, function(pop) {
  #Counts the number of non-reference sites in a gene
  keep = length(front_cols)+which(map$pop == pop)
  temp <- apply(ACMG_merged[,keep], 2, function(col) col!=0) %>% colSums
  c(mean(temp), sd(temp))
}) %>% t %>% tbl_df -> values #Number of non-reference sites across the different populations
colnames(values) <- c("Mean","SD")
values$Population <- factor(pop.levels, levels = pop.levels)
values$Superpopulation <- factor(super[pop.levels], levels = super.levels)
prettyprint(values, title = "ACMG-56 Pathogenic: Mean in 1000 Genomes", sd = T, ylimit = NULL, 
            xlabel = "Population", ylabel = "Mean No. of Non-Reference Sites")

### ExAC
#Each element is the probability that at least 1 of the 2 alleles are non-reference.
exac_prob <- (1-(1-merged_exac[,sprintf("AF_EXAC_%s",super.levels)])^2)
exac_values <- data.frame(exac_prob %>% colSums(na.rm = T), super.levels)
colnames(exac_values) = c("values","Superpopulation")
ggplot(exac_values, aes(x = Superpopulation, y=values, fill = Superpopulation)) + 
  geom_bar(stat = "identity") + ggtitle("ACMG-56 Pathogenic: Mean in ExAC") + 
  xlab("Population") + ylab("Mean No. of Non-Reference Sites") + theme_minimal() + 
  ylim(0,1.1*max(exac_values$values))
```

> 5. Fraction of 1000 Genomes Individuals with Pathogenic Sites

```{r frac_var_plot}
### 1000 Genomes
sapply(pop.levels, function(pop) {
  #Counts the number of non-reference sites in a gene
  keep = length(front_cols)+which(map$pop == pop)
  temp <- colSums(ACMG_merged[,keep])>0
  c(mean(temp),sd(temp))
}) %>% t %>% tbl_df -> values #Number of non-reference sites across the different populations
colnames(values) <- c("Mean","SD")
values$Population <- factor(pop.levels, levels = pop.levels)
values$Superpopulation <- factor(super[pop.levels], levels = super.levels)
prettyprint(values, title = "ACMG-56 Pathogenic: Fraction", sd = F, ylimit = NULL, 
            xlabel = "Population", ylabel = "Fraction with at least 1 non-reference site")

### ExAC
#Each element is the probability that at least 1 of the 2 alleles are non-reference.
exac_prob <- (1-(1-merged_exac[,sprintf("AF_EXAC_%s",super.levels)])^2)
exac_values <- data.frame(1-apply(1-exac_prob, 2, prod, na.rm = T), super.levels)
colnames(exac_values) = c("values","Superpopulation")
ggplot(exac_values, aes(x = Superpopulation, y=values, fill = Superpopulation)) + 
  geom_bar(stat = "identity") + ggtitle("ACMG-56 Pathogenic: Mean in ExAC") + 
  xlab("Population") + ylab("Fraction with at least 1 non-reference site") + theme_minimal() + 
  ylim(0,1.05*max(exac_values$values))
```

> 6. Ethnic Breakdown of 1000 Genomes Pathogenic Variants

```{r variants_by_ethnicity} 
### 1000 Genomes
front_cols <- 1:(grep("HG00096",colnames(merged_1000g))-1)
sapply(merged_1000g$VAR_ID, function(variant) {
  sapply(super.levels, function(x) {
    merged_1000g[merged_1000g$VAR_ID==variant,length(front_cols)+which(map$super_pop == x)] %>% unlist %>% sum
  }) 
}) %>% t-> temp
ord <- order(apply(temp,1,var), decreasing = T)
ranked_var <- temp[ord[1:8],]
par(mar=c(5, 8, 5, 2)) #changes plotting window to have greater left-margins
barplot(t(ranked_var), xlab = "Proportion of Variants across 1000 Genomes Cohort",
        main = "Sketchy: Ethnic Breakdown of 1000 Genomes Pathogenic Variants",
        col = c("red","gold3","springgreen3","deepskyblue","violet"),
        horiz = T, las = 1, legend = super.levels, cex.names = 0.8)
par(mar=c(5, 4, 4, 2)+0.1)

### ExAC
exac_prob <- (1-(1-merged_exac[,sprintf("AF_EXAC_%s",super.levels)])^2)
ord <- order(apply(exac_prob,1,sum), decreasing = T)
ranked_sum <- merged_exac[ord[1:8], sprintf("AF_EXAC_%s",super.levels)]
rownames(ranked_sum) <- merged_exac$VAR_ID[ord[1:8]]
par(mar=c(5, 8, 5, 2)) #changes plotting window to have greater left-margins
barplot(t(ranked_sum), xlab = "AF of Variants across 1000 Genomes Cohort",
        main = "Sketchy: Ethnic Breakdown of ExAC Pathogenic Variants",
        col = c("red","gold3","springgreen3","deepskyblue","violet"),
        horiz = T, las = 1, legend = super.levels, cex.names = 0.8)
par(mar=c(5, 4, 4, 2)+0.1)
```

> 7. Test Statistics: 

F-statistic/T-statistic: probability that the different groups are sampled from distributions with the same mean.
These are from the Fraction plot, but can be replicated for non-reference means and pathogenic means as well.

```{r test_stats}
#Calculating test statistics (F-values)
Fcalc <- function(values, pop) {
  if (missing(pop)) {
    groups <- super[pop.levels]
  } else {
    groups <- ifelse(super[pop.levels]==pop,pop,"Other")
  }
  data <- data.frame(y = values, group = factor(groups))
  color_map <- c("red","gold3","springgreen3","deepskyblue","violet","white") %>% 
    setNames(c("AFR","AMR","EAS","EUR","SAS","Other"))
  out <- lm(y ~ group, data) %>% anova
  plot(y ~ group, data, xlab = NULL, ylab = NULL, 
       col = color_map[sort(unique(groups))], main = out$`Pr(>F)`[1] %>% signif(3))
  out
}
par(mfrow=c(2,3))
F_values <- c(Fcalc(values$Mean)$`Pr(>F)`[1] %>% setNames("Overall"), 
              sapply(super.levels, function(pop) {
                Fcalc(values$Mean, pop)$`Pr(>F)`[1]
              }))
par(mfrow=c(1,1))
#F_values
```

## Penetrance Estimates

```{r lit_af}
#manually curated
tags <- c("adenomatous", rep("aneurysm",3), rep("arrhythmogenic;dreifuss",5),
          rep("breast;ovarian",2),"brugada;gardner","tachycardia","dilated",
          "ehler", "fabry","hypercholesterolemia",rep("hypertrophic",8), 
          "medullary", "hypercholesterolemia","noncompaction","Fraumeni",
          rep("Loeys;Dietz",5), rep("QT",3),"lynch;endometrial", 
          "hyperthermia", "Marfan",rep("neoplasia;men2a",3),"MYH;colon",
          "neurofibromatosis", rep("paraganglioma;pheochromocytoma",4),
          "peutz;jeghers","pilomatrixoma","Cowden;PTEN;hamartoma;Merkel",
          "retinoblastoma",rep("tuberous",2),"Hippel;Lindau","Wilms")

# assumes independence

#Adapt AF_1000G and AF_EXAC

getAlleleFreq <- function(input, tags, ind) {
  temp <- sapply(unique(tags), function(tag) {
    tag.vec <- strsplit(tag,";") %>% unlist
    loc <- rep(FALSE, nrow(input))
    for(tag in tag.vec)
      loc <- loc | grepl(tag,input$CLNDBN, ignore.case = T)
    #loc = locations of all the "hits"
    hits <- sum(loc)
    if (ind) {
      freq <- input[loc,"AF_1000G"] %>% unlist %>% as.numeric
      final <- 1-prod(1-freq[!is.na(freq)])
    } else {
      final <- mean(colSums( input[loc,(1+length(front_cols)):ncol(input)] ))/2
    }
    c(final, hits) %>% setNames(c("AF_1000G","Hits"))
  }) %>% t %>% tbl_df
  data.frame("Tags" = unique(tags), temp)
}

freq_1000g.dep <- getAlleleFreq(merged_1000g, tags, ind = F)
freq_1000g.indep <- getAlleleFreq(merged_1000g, tags, ind = T)
#freq_exac.sub <- getAlleleFreq(ACMG_merged,tags,dataset="ExAC")
#freq_exac.full <- getIndAlleleFreq(data.clinvar %>% rename(DISEASE_LIST = Disease),tags,dataset="ExAC")
allele.freq <- data.frame("Pattern" = tags %>% unique,
                   COUNT_1000G = freq_1000g.dep$AF, INDEP_1000G = freq_1000g.indep$AF)
                   #, INDEP_ExAC_SUB = freq_exac.sub$AF, INDEP_EXAC_FULL = freq_exac.full$AF)
missing <- lapply(2:ncol(allele.freq), function(col) {
  allele.freq$Disease[allele.freq[,col]==0] %>% as.character
}) %>% setNames(colnames(allele.freq)[2:ncol(allele.freq)])
#pairs(allele.freq[,2:ncol(allele.freq)])
```

> 1. Manually curated disease keywords from CLNDBN

```{r} 
allele.freq[,"Pattern"]
```

> 2. Comparisons of allele frequencies by calculation method

``` {r}
plot(allele.freq[,2:ncol(allele.freq)]+0.001, log = "xy", main = "Counting vs. Independence_Assumption (log-log scale)")
cor(allele.freq[,2:ncol(allele.freq)])
```

> 3. What fraction of people have an LP/P mutation in each disease category?

```{r LP/P_freq_by_disease, fig.width = 10}
#Plots aggregate AF by disease: P(V)
bp <- allele.freq$COUNT_1000G %>% setNames(allele.freq$Pattern) %>% sort(decreasing = T)
par(mar=c(5, 18, 5, 2)) #changes plotting window to have greater left-margins
barplot(bp, las = 2, pch = 'h', xlab ="P(having a variant)", main = "Carrier frequency by disease",
        horiz = T, xlim = c(0,max(bp))*1.1, las = 1, cex.names = 0.8)
par(mar=c(5, 4, 4, 2)+0.1) #resets margins
```

> 4. Penetrance as a function of allelic heterogeneity: P(V|D) = 0.001, 0.02, 0.5

```{r penetrance_f_AH, fig.width = 10}
colclass <- rep("character",15)
colclass[c(3:5,9,13)] <- "numeric"
ACMG_Lit <- read.csv(file = "ACMG_Lit_Small.csv", header = TRUE, stringsAsFactors = F, na.strings = "\\N",
                     colClasses = colclass)
# Map of disease name to disease tags
disease <- ACMG_Lit$Disease
named.freqs <- bp %>% setNames(disease)
named.prev <- 1/ACMG_Lit$Inverse.Prevalence %>% setNames(disease)
# Repeats allow for correct quartile calculations
ah_low <- 0.001
ah_high <- 0.5
#point estimate set to geometric mean
allelic.het <- c(ah_low, ah_low, sqrt(ah_low*ah_high) %>% round(3), ah_high, ah_high)
# Matrix of penetrance values for allelic het range, capped at 1
penetrance <- pmin(1, as.vector(allelic.het %o% (named.prev/named.freqs)))
order(penetrance[c(F,F,T,F,F)], decreasing = T) -> ord
# replicate each element n times to create labels
data <- data.frame("penetrance" = penetrance, "disease" =
            factor(sapply(disease, function(x) rep(x,length(allelic.het))) %>% as.vector,
                  levels = disease[ord]) )
par(mar=c(5, 20, 5, 2))
boxplot(penetrance ~ disease, data, horizontal = TRUE, las = 1, xlab = "Penetrance", main = "Penetrance Range Estimates for P(V|D)", cex.axis = 0.7)
abline(v=0.5, lty=2)
```

```{r pen_cdf} 
par(mar=c(5, 12, 5, 2))
data$penetrance[seq(5,150,5)] %>% ecdf %>% 
  plot(ylab = "Fraction with max theoretical penetrance < P", xlab = "P", main = "Penetrance CDF")
par(mar=c(5, 4, 4, 2)+0.1)
```

```{r penetrance_f_prev, fig.width = 10}
#Take transcription regions to relabel the diseases:
ranged <- !is.na(ACMG_Lit$Inverse.P2)
doubles <- ACMG_Lit[ranged,1:5]
prev.range <- 1/doubles[,c(3,3,5,4,4)] %>% as.matrix
```

> 5. Empirical prevalence ranges 

``` {r prev_range, fig.wigth = 10}
par(mar=c(5, 15, 5, 2))
temp <- doubles$Inverse.P1/doubles$Inverse.P2 %>% setNames(doubles$Disease)
barplot(temp, horiz = T, las = 1, xlim = c(0,ceiling(max(temp)/5)*5), xlab = "Ratio of prevalence high/low", main = "Range of prevalence estimates")
par(mar=c(5, 4, 4, 2)+0.1)
```

> 6. Penetrance as a function of prevalence - P(V|D) set to 0.1

``` {r disp_prev_plot_1, fig.width = 10}
#Set this to 1 rather than 0.02
penetrance_out <- function(allelic.het) {
  penetrance <- (allelic.het*prev.range/allele.freq$COUNT_1000G[ranged]) %>% 
    t %>% as.vector %>% pmin(1)
  ord <- order(penetrance[c(F,F,T,F,F)] %>% as.vector, decreasing = T)
  # replicate each element n times to create labels
  data.frame("penetrance" = penetrance,
    "disease" = factor(sapply(doubles$Disease, function(x) rep(x,5)) %>% as.vector,
    levels = doubles$Disease[ord])
  )
}
par(mar=c(5, 15, 5, 2))
boxplot(penetrance ~ disease, penetrance_out(0.1), horizontal = TRUE, las = 1, range = 0, 
        xlab = "Penetrance", ylim = c(0,1),
        main = "Penetrance Range Estimates for Prevalence Ranges, P(V|D) = 0.1")
abline(v=0.5, lty=2)
```

> 7. Penetrance as a function of prevalence - P(V|D) set to 1

``` {r disp_prev_plot_2, fig.width = 10}
par(mar=c(5, 15, 5, 2))
boxplot(penetrance ~ disease, penetrance_out(1), horizontal = TRUE, las = 1, range = 0, 
        xlab = "Penetrance", ylim = c(0,1),
        main = "Penetrance Range Estimates for Prevalence Ranges, P(V|D) = 1")
abline(v=0.5, lty=2)
```

``` {r cleanup, cache = F}
dir.files <- system("ls", intern = T)
if ("1000G" %in% dir.files)
  system("rm -r 1000G")
if ("ACMG_1000G" %in% dir.files)
  system("rm -r ACMG_1000G")
```

